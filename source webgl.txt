http://www.iquilezles.org/apps/shadertoy/
ex usage:

vec2 p = -1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
    vec2 m = -1.0 + 2.0 * mouse.xy / resolution.xy;

    float a1 = atan(p.y-m.y,p.x-m.x);
    float r1 = sqrt(dot(p-m,p-m));
    float a2 = atan(p.y+m.y,p.x+m.x);
    float r2 = sqrt(dot(p+m,p+m));

    vec2 uv;
    uv.x = 0.2*time + (r1-r2)*0.25;
    uv.y = sin(2.0*(a1-a2));

    float w = r1*r2*0.8;
    vec3 col = texture2D(tex0,uv).xyz;

    gl_FragColor = vec4(col/(.1+w),1.0);
	
	
	----------------------------
	
#ifdef GL_ES
precision highp float;
#endif

uniform float time;
uniform vec2 resolution;
uniform vec4 mouse;
uniform sampler2D tex0;
uniform sampler2D tex1;

void main(void)
{
	float h = mod(time / 1.0, 1.0);
	float s = 1.0;
	float l = 0.5;
	
	// TODO: prendre h tel quel!
	
	float h1 = h * 6.0;
	float c = s * ( 1.0 - abs( 2.0 * l - 1.0 ));
	float x = c * ( 1.0 - abs( mod( h1 , 2.0 ) - 1.0 ));
	float m = l - c / 2.0;

	float r1 = 0.0;
	float g1 = 0.0;
	float b1 = 0.0;	
	
	if ( h1 >= 5.0 ) {
		r1 = c ;
		b1 = x ;
	} else if ( h1 >= 4.0 ) {
		r1 = x ;
		b1 = c ;
	} else if ( h1 >= 3.0 ) {
		g1 = x ;
		b1 = c ;
	} else if ( h1 >= 2.0 ) {
		g1 = c ;
		b1 = x ;
	} else if ( h1 >= 1.0 ) {
		r1 = x ;
		g1 = c ;
	} else {
		r1 = c ;
		g1 = x ;
	}
	
	gl_FragColor = vec4( r1 + m , g1 + m , b1 + m , 1.0 );
}
	
	
	----------------------------
	
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
We attach
	

doc: http://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf
utiliser:
    -framebuffer qu'on shade pour calculer une partie de l'intégrale (http://learningwebgl.com/blog/?p=1786)
      --> ça va pas marcher, il faudrait pouvoir sortir au format 3 floats compris entre 0 et 1.
        '-> OpenCl, WebCl?
		'-> Utiliser un Vertex Shader au lieu d'un Fragment Shader?
		  (http://stackoverflow.com/questions/5497722/how-can-i-animate-an-object-in-webgl-modify-specific-vertices-not-full-transfor)
		  '-> essayer de binder avec bufferData un array_buffer (buffer object) avec dynamic_draw
		  '-> getParameter(max_vertex) nous dit que la limitation de l'index c'est pour des array de vertex? (bad si ça concerne l'input des arrays aux vertex shaders..)
    -shader pour hsl to rgb à la fin (cf après)
	
	