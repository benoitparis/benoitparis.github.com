<html>
	<head>
	</head>
	<body onload="start();">
		<button onclick="location.href=location.href;">Reset</button>
		<button onclick="circleButton();">Cercle</button>
		<button onclick="squareButton();">Carré</button>
		<button onclick="levyButton();">Dragon de Levy</button></br>
		<canvas id="canvasIntegral" style="" width="512" height="512">Cette animation ne marche qu'avec Google Chrome</canvas></br>
		<input id="console" type="text" value=".." style="width:512px;"></input>
		<script>
		
		
			var gl, hslToRgbProgram, calcProgram, calcPreCalcProgram, preCalcProgramRe, preCalcProgramIm, frame0, frame1, preCalcFrameRe, preCalcFrameIm;
			var segmentArray = [];
			var drawPrecision = 0.002;
			var landOnGrid = true;
			var mouseLastOffsetX = -1;
			var mouseLastOffsetY = -1;
			
						
			function start() {
			
				document.getElementById('canvasIntegral').onmousemove = function(e){
					if (e.which ===1){
						if (mouseLastOffsetX !== -1) {
							line([mouseLastOffsetX/512,1-mouseLastOffsetY/512,e.offsetX/512,1-e.offsetY/512]);
							repaint();
						}					
						mouseLastOffsetX = e.offsetX;
						mouseLastOffsetY = e.offsetY;				
					} else {
						mouseLastOffsetX = -1
					}
				};
			
				var canvas = document.getElementById("canvasIntegral");
				gl = getGl(canvas);
				
				frame0 = createFrame(512);
				frame1 = createFrame(512);
				preCalcFrameRe = createFrame(1024);
				preCalcFrameIm = createFrame(1024);
				
				var vertexShader = getShader("shader-vertex");
				var hslToRgbShader = getShader("shader-hsltorgb");
				var calcShader = getShader("shader-calc");
				var calcShaderPreCalc = getShader("shader-precalc");
				var preCalcShaderRe = getShader("shader-precalc-re");
				var preCalcShaderIm = getShader("shader-precalc-im");

				hslToRgbProgram = getProgram(vertexShader,hslToRgbShader);
				calcProgram = getProgram(vertexShader,calcShader);
				calcPreCalcProgram = getProgram(vertexShader,calcShaderPreCalc);
				preCalcProgramRe = getProgram(vertexShader,preCalcShaderRe);
				preCalcProgramIm = getProgram(vertexShader,preCalcShaderIm);
				
				preCalc();
				
				// input hooks				
				var hslSamp = gl.getUniformLocation(hslToRgbProgram, "u_hslSamp");
				var calcSamp = gl.getUniformLocation(calcProgram, "u_calcSamp");
				var aVec2    = gl.getUniformLocation(calcProgram, "u_a");
				var dxVec2   = gl.getUniformLocation(calcProgram, "u_dx");
				var calcSampPreCalc = gl.getUniformLocation(calcPreCalcProgram, "u_calcSamp");
				var reSamp = gl.getUniformLocation(calcPreCalcProgram, "u_precalcRe");
				var ImSamp = gl.getUniformLocation(calcPreCalcProgram, "u_precalcIm");
				var aVec2PreCalc    = gl.getUniformLocation(calcPreCalcProgram, "u_a");
				var dxVec2reCalc   = gl.getUniformLocation(calcPreCalcProgram, "u_dx");
				gl.enableVertexAttribArray(0);
				
				createVertices();
				
				// data setup
				gl.uniform1i(hslSamp, 0);
				gl.uniform1i(calcSamp, 0);
				gl.uniform1i(calcSampPreCalc, 0);
				gl.uniform1i(reSamp, 1);
				gl.uniform1i(ImSamp, 2);
				
				// calc	config			
				var lastFrameOutput = 1;
				var needToRepaint = true;
				var startTime = Date.now();
				var lastRepaintDate = Date.now();
				var lastRepaintTime = 250;
				var numberOfCalcCycles = 5;
				drawPrecision = 0.005;
				landOnGrid = true;
				
				
				/*line([0.8,1.0,0.0,0.0]);
				line([0.0,0.0,0.6,1.0]);
				line([0.4,1.0,0.0,0.0]);
				line([0.0,0.0,0.2,1.0]);*/
				
				
				//shuffle();
				
				/*
				TODO:
				Test with high density grid of segments array weirdly oriented
				With a generator that can accept modificators of mod+x elements
				Also, make the dx value definable by a function of the position (ex what does a vortex look like?).
				*/
				

				
				/*
				// 512x512 sized levy dragon
				levyDragon(0.4 ,0.2, 0.8 , 0.6 );
				line( [.8, .6, .4, .2] );
				*/
				/*
				// symetry wrapper with funny parameters
				// a faire avec des segments array!
				drawPrecision = 0.4;
				
				var sens = 
					[ -1.0 , -1.0 , 
					  +1.0 , +1.0 ];
				var direction = 
					[ 1.0 , -1.0 , 
					  -1.0 , 1.0 ];
				var position = 1.0;
				
				line(
					[ 0.5-0.5*sens[0]             -0.25*position, 
					  0.5-0.5*sens[0]*direction[0]+0.25         , 
					  0.5+0.5*sens[0]             -0.25*position, 
					  0.5+0.5*sens[0]*direction[0]+0.25         ]);
				line(
					[ 0.5-0.5*sens[1]             +0.25         , 
					  0.5-0.5*sens[1]*direction[1]+0.25*position, 
					  0.5+0.5*sens[1]             +0.25         , 
					  0.5+0.5*sens[1]*direction[1]+0.25*position]);
				line(
					[ 0.5-0.5*sens[2]             -0.25         , 
					  0.5-0.5*sens[2]*direction[2]-0.25*position, 
					  0.5+0.5*sens[2]             -0.25         , 
					  0.5+0.5*sens[2]*direction[2]-0.25*position]);
				line(
					[ 0.5-0.5*sens[3]             +0.25*position, 
					  0.5-0.5*sens[3]*direction[3]-0.25         , 
					  0.5+0.5*sens[3]             +0.25*position, 
					  0.5+0.5*sens[3]*direction[3]-0.25         ]);
				*/
				
				/*
				// b/w alternate
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+(i-0.25)/5.0,0.0+(i-0.25)/5.0,1.0+(i-0.25)/5.0,1.0+(i-0.25)/5.0]);
					line([1.0+(i+0.25)/5.0,1.0+(i+0.25)/5.0,0.0+(i+0.25)/5.0,0.0+(i+0.25)/5.0]);
				}
				*/
				
				/*
				// zipped line with parabolas
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+(i-0.25)/50.0,0.0+(i-0.25)/50.0,1.0+(i-0.25)/50.0,1.0+(i-0.25)/50.0]);
					line([1.0+(i+0.25)/50.0,1.0+(i+0.25)/50.0,0.0+(i+0.25)/50.0,0.0+(i+0.25)/50.0]);
				}
				*/
				/*
				// zip zoom
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+(i-0.25)/5.0,0.0-(i-0.25)/5.0,1.0+(i-0.25)/5.0,1.0-(i-0.25)/5.0]);
					line([1.0+(i+0.25)/5.0,1.0-(i+0.25)/5.0,0.0+(i+0.25)/5.0,0.0-(i+0.25)/5.0]);
				}
				*/
				/*
				// separation coloree
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+i/5.0,0.0-i/5.0,1.0+i/5.0,1.0-i/5.0]);
				}
				*/
				
				/*
				// nice diagonals
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+i/25.0,0.0+i/25.0,1.0+i/25.0,1.0+i/25.0]);
				}
				*/
				/*
				// diagonal balls
				// drawPrecision = 10.0;
				for ( var i = -10 ; i < 11 ; i++ ) {
					line([0.0+i/10.0,0.0+i/10.0,1.0+i/10.0,1.0+i/10.0]);
				}
				*/
				
				// funny balls extension
				// drawPrecision = 0.1;
				// drawPrecision = 10.0;
				/*
				for ( var i = -2 ; i < 2 ; i++ ) {
					line([0.05+i/10.0,0.05+i/10.0,1.05+i/10.0,1.05+i/10.0]);
				}
				*/
				/*
				// funny ball
				// drawPrecision = 10.0;
				line([-0.05,-0.05,0.95,0.95]);
				line([0.05,0.05,1.05,1.05]);
				*/
				
				
				// rounding errors zoom, patterns fun
				// precision 10000000
				// rounding debut à 200
				// rounding exemple à 2000
				// pattern fun à 20000
				// 200000 on zoome sur les cercles concentriques puis les patterns complesxes centraux apparaissent 
				/*
				drawPrecision = 1.0;
				for ( var i = 201 ; i>0 ; i-- ) {
					line([1.0,1.0,0.0,0.0]);
				}
				line([-100.0,-100.0,101.0,101.0]);
				*/
				
				/*				
				// creep lumineux
				// avec précision 0.05
				for ( var i = 40 ; i>0 ; i-- ) {
					rect(0.5-i/80,0.5-i/80,i/40,i/40);
				}
				*/	
				
				// flux à droite
				// avec précision 0.05
				/*
				drawPrecision = 0.05;
				for ( var i = 120 ; i>0 ; i-- ) {
					circle(i/30,0.5,i/40);
				}
				*/
				
				
				
				function calculateSegment(currentPoint, precalc) {
					var currentTexture, currentFrameBuffer;
					if ( lastFrameOutput == 1 ) {
					 	currentTexture = frame1.texture;
						currentFrameBuffer = frame0.frameBuffer; 
						lastFrameOutput = 0 ;
					} else {
						currentTexture = frame0.texture ;
						currentFrameBuffer = frame1.frameBuffer ; 
						lastFrameOutput = 1 ;
					}
					gl.bindTexture(gl.TEXTURE_2D, currentTexture);
					gl.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
					
					if (precalc) {
						gl.useProgram(calcPreCalcProgram);
						gl.uniform2f(aVec2PreCalc , currentPoint[0], currentPoint[1]);
						gl.uniform2f(dxVec2reCalc, currentPoint[2], currentPoint[3]);

					} else {
						gl.useProgram(calcProgram);
						gl.uniform2f(aVec2 , currentPoint[0], currentPoint[1]);
						gl.uniform2f(dxVec2, currentPoint[2], currentPoint[3]);
					}					
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
					gl.flush(); 
					needToRepaint = true;
				}
				
				repaint = function () {
					gl.useProgram(hslToRgbProgram);
					gl.bindTexture(gl.TEXTURE_2D, lastFrameOutput == 1 ? frame1.texture : frame0.texture );
					gl.bindFramebuffer(gl.FRAMEBUFFER, null);
					gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
					gl.flush();
					var now = Date.now();
					lastRepaintTime = now - lastRepaintDate;
					lastRepaintDate = now ;					
					needToRepaint = false;					
					run();
				}
				
				function run() {
				
					// live impedance adaptation between need to repaint and stacking instructions in the GPU
					// we need at least 5 calc cycles to be executed
					// benchmark indicates good values for idealFrameTime are between 30ms (33Hz) and 40ms (25Hz).
					// benchmark @ 512x512, 2000 segments, min 1 calc cycles to be executed:
					// 10 ms    --> 54081 ms
					// 15 ms    --> 53281 ms
					// 17 ms    --> 44953 ms 60Hz. few stackings of multiple cycles
					// 20 ms    --> 22292 ms
					// 25 ms    --> 7953  ms
					// 30 ms    --> 7256  ms
					// 35 ms    --> 6033  ms
					// 40 ms    --> 5622  ms 25Hz limit
					// 50 ms    --> 5120  ms
					// 60 ms    --> 4407  ms
					// 100 ms   --> 3787  ms
					// 200 ms   --> 3346  ms
					// 500 ms   --> 2369  ms
					// 1000 ms  --> 1625  ms
					// 2000 ms  --> 1741  ms
					// 5000 ms  --> 1899  ms
					// 10000 ms --> 3490  ms time increase effect unknown (WebGL cached internal stack blown?)
					
					var idealFrameTime = 40;
					
					numberOfCalcCycles = Math.min(100,Math.floor(Math.max(5, numberOfCalcCycles + (idealFrameTime - lastRepaintTime) / 5.0)));
					document.getElementById('console').value = "Dernier temps: " + lastRepaintTime + "ms. Rajout de " + numberOfCalcCycles + " cycles. Plus que: " + segmentArray.length + " segments.";

					for(var i = 0 ; i < numberOfCalcCycles && segmentArray.length > 0 ; i++) {
						calculateSegment(segmentArray.pop(), false);
					}
					if (needToRepaint) {
						if (window.webkitRequestAnimationFrame)
							window.webkitRequestAnimationFrame(repaint);
						else
							repaint();
					}
				}
			
				
				run();
			}

			function levyButton(){
				levyDragon(0.4 ,0.2, 0.8 , 0.6 );
				line( [.8, .6, .4, .2] );
				shuffle();
				repaint();
			}

			function circleButton(){
				circle(0.5,0.5,0.25);
				repaint();
			}

			function squareButton(){
				rect(0.25,0.25,0.5,0.5);
				repaint();
			}
			
			
			function getGl(canvas){
				// init WebGL with floating point operations
				var result;
				try {
					result = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
				} catch(e) {
					console.log("Problem loading WebGL"); 
					console.log(e.toString()); 
				}
				result.getExtension("OES_texture_float");
				return result;			
			}
			
			function createFrame(n){
				// init FrameBuffers, associate with textures
				var texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);		
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, n, 0, gl.RGBA, gl.FLOAT, null);
				
				var frameBuffer = gl.createFramebuffer();
				gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
				gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
				return { texture:texture, frameBuffer:frameBuffer };
			}
			
			function getShader(nodeId){
				// shader creation
				var shaderSourceNode = document.getElementById(nodeId);		
				var shaderSource = shaderSourceNode.firstChild.textContent;				
				var shader = gl.createShader(shaderSourceNode.type == "x-shader/x-vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER );
				gl.shaderSource(shader, shaderSource);
				gl.compileShader(shader);
				console.log(nodeId +" compile status = " + gl.getShaderParameter(shader, gl.COMPILE_STATUS));
				return shader;
			}
			
			function getProgram(vertexShader, fragmentShader) {
				var program = gl.createProgram();
				gl.attachShader(program, vertexShader);
				gl.attachShader(program, fragmentShader);
				gl.linkProgram(program);
				console.log("Program link status = " + gl.getProgramParameter(program, gl.LINK_STATUS));
				return program;
			}
			
			function createVertices(){
				// vertices definition and binding
				gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
				var vertices = [ -1., -1., 1., -1., 1., 1., -1., 1., -1., -1. ];
				gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
			}
			
			function preCalc(){
				var precision  = gl.getUniformLocation(preCalcProgramRe, "u_precision");
				gl.uniform1f(precision , drawPrecision);
				gl.useProgram(preCalcProgramRe);
				gl.bindFramebuffer(gl.FRAMEBUFFER, preCalcFrameRe.frameBuffer);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
				gl.flush(); 
				
				var precision  = gl.getUniformLocation(preCalcProgramIm, "u_precision");
				gl.uniform1f(precision , drawPrecision);
				gl.useProgram(preCalcProgramIm);
				gl.bindFramebuffer(gl.FRAMEBUFFER, preCalcFrameIm.frameBuffer);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 5);
				gl.flush(); 
				
				gl.activeTexture(gl.TEXTURE1);
				gl.bindTexture(gl.TEXTURE_2D, preCalcFrameRe.texture);
				
				gl.activeTexture(gl.TEXTURE2);
				gl.bindTexture(gl.TEXTURE_2D, preCalcFrameIm.texture);
				
				// reset. Useful where?
				gl.activeTexture(gl.TEXTURE0);
			}
			
			// shapes
			function performanceTestShape() {
				// -!TODO- find what the grid is for ~(drawPrecision optimal tuning)
				// --> done: landOnGrid()
				// --> good grid here is : 
				//  / / / /
				// / / / /  with 1/512 = 0.00048828125*4 as step
				for (var i = 0 ; i < 2047 ; i++){
					segmentArray.push([1.0 - i/2047 , 1.0 - i/2047, 1/2047, 1/2047]);
				}
				repaint();
			}
			
			// TODO gerer le segment simple aussi
			function line(points, pointsOnGrid){
				var ax = points[0];
				var ay = points[1];
				var bx = points[2];
				var by = points[3];
				if (landOnGrid && !pointsOnGrid) {
					ax = getGridPoint(ax);
					ay = getGridPoint(ay);
					bx = getGridPoint(bx);
					by = getGridPoint(by);
				}
				var cx = (ax+bx)/2.0;
				var cy = (ay+by)/2.0;
				if (Math.abs(ax-bx) > drawPrecision*2 || Math.abs(ay-by) > drawPrecision*2 ) {

					if (landOnGrid) {
						cx = getGridPoint(cx);
						cy = getGridPoint(cy);

						//console.log(ax,ay,cx,cy,bx,by);
						if(Math.abs(ax-cx)> 1/1024 || Math.abs(ay-cy)> 1/1024){
							line([ax,ay,cx,cy], true);
						}
						if(Math.abs(bx-cx)> 1/1024 || Math.abs(by-cy)> 1/1024){
							line([cx,cy,bx,by], true);
						}
					} else {
						line([ax,ay,cx,cy]);
						line([cx,cy,bx,by]);
					}
				} else {
					segmentArray.push([ cx, cy, bx-ax, by-ay ]);
				}
				
			}
			function rect( ax, ay, sx, sy){
				line([ax,ay,ax+sx,ay]);
				line([ax+sx,ay,ax+sx,ay+sy]);
				line([ax+sx,ay+sy,ax,ay+sy]);
				line([ax,ay+sy,ax,ay]);
			}
			function circle( ax, ay, r ){
				var iMax = Math.ceil(2 * Math.PI * r / drawPrecision);
				var lastX = ax + r;
				var lastY = ay;
				for ( var i = 0; i<=iMax; i++){
					var theta = i / iMax * 2 * Math.PI;
					var newX = ax + r * Math.cos(theta);
					var newY = ay + r * Math.sin(theta);
					line([lastX,lastY,newX,newY]);
					lastX = newX;
					lastY = newY;
				}
			}
			function levyDragon( ax, ay, bx, by ) {
				if ( (Math.abs(ax-bx) > drawPrecision || Math.abs(ay-by) > drawPrecision)) {
					var cx = ax + -( by - ay - bx + ax ) / 2;
					var cy = ay + ( by - ay + bx - ax ) / 2;
					levyDragon( ax, ay , cx, cy );
					levyDragon( cx, cy , bx, by );
				} else {
					line( [ax, ay, bx, by] );
				}
			}
			
			function shuffle() {
				for(	var j, x, i = segmentArray.length;
						i;
							j = parseInt(Math.random() * i),
							x = segmentArray[--i],
							segmentArray[i] = segmentArray[j],
							segmentArray[j] = x
					) {}
			}
			
			function getGridPoint(p) {
				return Math.round(p*512)/512;
			}
			</script>
		<script id="shader-hsltorgb" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform sampler2D u_hslSamp;
			
			void main(void)
			{
				
				float h = mod(texture2D(u_hslSamp, gl_FragCoord.xy / vec2( 512.0 , 512.0 )).r / (12.0*6.28318531) , 1.0 ) ;
				float s = 1.0;
				float l = 0.5 + 0.5 * atan(texture2D(u_hslSamp, gl_FragCoord.xy / vec2( 512.0 , 512.0 )).g) / 1.57079633;
								
				float h1 = h * 6.0;
				float c = s * ( 1.0 - abs( 2.0 * l - 1.0 ));
				float x = c * ( 1.0 - abs( mod( h1 , 2.0 ) - 1.0 ));
				float m = l - c / 2.0;

				float r1 = 0.0;
				float g1 = 0.0;
				float b1 = 0.0;	
				
				if ( h1 >= 5.0 ) {
					r1 = c ;
					b1 = x ;
				} else if ( h1 >= 4.0 ) {
					r1 = x ;
					b1 = c ;
				} else if ( h1 >= 3.0 ) {
					g1 = x ;
					b1 = c ;
				} else if ( h1 >= 2.0 ) {
					g1 = c ;
					b1 = x ;
				} else if ( h1 >= 1.0 ) {
					r1 = x ;
					g1 = c ;
				} else {
					r1 = c ;
					g1 = x ;
				}
				
				gl_FragColor = vec4( r1 + m , g1 + m , b1 + m , 1.0 );
			}
		</script>
		<script id="shader-calc" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform sampler2D u_calcSamp;
			uniform vec2 u_a;
			uniform vec2 u_dx;
			
			void main(void)
			{
				vec2 pos = gl_FragCoord.xy / 512.0;
				vec2 prev = texture2D( u_calcSamp , pos ).xy;
				vec2 delta = pos - u_a;
				float denom = dot( delta , delta );
				gl_FragColor = vec4( prev.x + ( delta.x * u_dx.y - delta.y * u_dx.x) / denom  , prev.y + dot( delta , u_dx ) / denom , 1.0 , 1.0 );
			}
		</script>
		<script id="shader-precalc" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform sampler2D u_calcSamp;
			uniform sampler2D u_precalcRe;
			uniform sampler2D u_precalcIm;
			uniform vec2 u_a;
			uniform vec2 u_dx;
			
			void main(void)
			{
				vec2 pos = gl_FragCoord.xy / 512.0;
				vec2 prev = texture2D( u_calcSamp , pos ).xy;
				vec2 delta = pos - u_a;
				vec2 dxRe = texture2D( u_precalcRe , delta ).xy;
				vec2 dxIm = texture2D( u_precalcIm , delta ).xy;
				gl_FragColor = vec4( prev.x + dxRe.x + dxIm.x , prev.y + dxIm.y + dxIM.y , 1.0 , 1.0 );
			}
		</script>
		<script id="shader-precalc-re" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform float u_precision;
			
			void main(void)
			{
				vec2 delta = (gl_FragCoord.xy / 512.0) - 1.0;
				float denom = dot( delta , delta );
				gl_FragColor = vec4( prev.x + ( - delta.y * u_precision) / denom  , prev.y + delta.x * u_precision / denom , 1.0 , 1.0 );
			}
		</script>
		<script id="shader-precalc-im" type="x-shader/x-fragment">
			#ifdef GL_ES
			precision highp float;
			#endif
			
			uniform float u_precision;
			
			void main(void)
			{
				vec2 delta = (gl_FragCoord.xy / 512.0) - 1.0;
				float denom = dot( delta , delta );
				gl_FragColor = vec4( prev.x + ( delta.x * u_dx.y ) / denom  , prev.y + delta.y * u_precision / denom , 1.0 , 1.0 );
			}
		</script>
		<script id="shader-vertex" type="x-shader/x-vertex">
			attribute vec2 a_pos;
			void main() {
				gl_Position = vec4(a_pos.x,a_pos.y,0.0,1.0);
			}
		</script>
	</body>
</html>