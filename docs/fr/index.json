[{"content":"Indice d\u0026rsquo;une courbe autour d\u0026rsquo;un point avec une Intégrale de Cauchy, en WebGL Voici une visualisation de l\u0026rsquo;indice -le nombre de tours- n(γ,a) d\u0026rsquo;une courbe γ autour du point a, exprimée selon un cas spécial de la Formule intégrale de Cauchy; avec une courbe qu\u0026rsquo;on ne ferme pas nécessairement sur elle-même. Les nombres complexes sont représentés dans un espace teinte-saturation.\n$$ n(\\gamma ,a) = \\frac{1}{2 \\pi i}\\int_{\\gamma}^{}\\frac{1}{z-a}dz $$\nDemo (faites glisser la souris/le pouce sur la surface rouge)\nReset\rShuffle\rCircle\rSquare\rLevy Dragon\r+\r-\rThis animation requires WebGL\nChaque pixel affiche par sa couleur son indice: la partie réelle donne la teinte, la partie imaginaire la luminance. Des formes prédéfinies sont mises à disposition.\nLa formule Pendant la démonstration de la Formule intégrale de Cauchy, on tombe sur une formule remarquable. Formée à partir de composantes innocentes complexes, elle donne toujours un nombre entier et réel. De plus, assez mystérieusement, elle indique le nombre de tour que la courbe fait autour du point! Mais on exige que la courbe soit fermée sur elle-même.\nNe me demandez pas une explication intuitive du phénomène: À vrai dire j\u0026rsquo;ai construit cette visualisation pour essayer de m\u0026rsquo;en faire une idée. Vous pouvez tenter de construire la votre à partir de ces réponses.\nDu coup, que se passe-t-il si on ne referme pas la boucle? Eh bien la formule nous renvoie une \u0026rsquo;erreur\u0026rsquo;, sous la forme d\u0026rsquo;un nombre qui comporte désormais une partie imaginaire. Une zone devient positive et demande qu\u0026rsquo;on parte de ce point (luminance élevée), ou bien négative (faible luminance) si il faut qu\u0026rsquo;on y aille. On peut alors \u0026lsquo;rendre le plan réel\u0026rsquo; en allant des parties lumineuses vers les sombres et effectivement clore les courbes sur elle-mêmes. La formule est fournie avec sa propre fonction de debogage!\nOn notera que l\u0026rsquo;inverse d\u0026rsquo;une courbe est la même courbe mais parcourue en sens inverse: on remplace $dz$ by $-dz$ dans la formule. Aussi, l\u0026rsquo;intégration (~somme, ici) est commutative et peut être effectuée dans n\u0026rsquo;importe quel ordre; c\u0026rsquo;est l\u0026rsquo;option \u0026lsquo;shuffle\u0026rsquo;.\nCeci signifie qu\u0026rsquo;on peut diviser une plus grande courbe en deux par un aller-retour entre deux de ses points, en réarrangeant les intégrales. Cette opération est l\u0026rsquo;identité, puisqu\u0026rsquo;on vient seulement de rajouter une courbe et son inverse. Et vice versa, on peut fusionner deux courbes ayant un bord commun en une plus grande.\nDiviser une courbe, si on regarde pas les artéfacts\nArtéfacts On peut configurer des niveaux de précision pour utiliser des $dz$ plus ou moins grands. Une précision plus fine aura moins de pointillés, une meilleure fidélité de l\u0026rsquo;intégration, ce sera plus lent; cependant on pourrait accumuler plus d\u0026rsquo;erreur due à l\u0026rsquo;imprecision des nombres flottants.\nSur mobile il se peut que vous ne voyiez pas de surface unie sur des courbes fermées. C\u0026rsquo;est dû au fait que les résultats intermédiaires sont stockés dans des textures en nombres flottants, et que WebGL ne donne que 4 bits sur mobile, alors qu\u0026rsquo;il en fournit 16 sur Desktop.\nCode Ici\nConstruction Bon, si vous voulez un calcul sur une zone de ~500x500 pixel pour une courbe de 1000 éléments, on est déjà à 250 million d\u0026rsquo;opérations; l\u0026rsquo;utilisation d\u0026rsquo;un GPU est donc pluc adaptée.\nJ\u0026rsquo;utilise deux fragment shaders. Un pour projeter les parties réeles et imaginaires, que je stocke dans les channels rouge et vert, dans un espace teinte-saturation-luminance. J\u0026rsquo;ai choisi la teinte pour la partie réelle parce qu\u0026rsquo;elle illustre un \u0026lsquo;degré de situation\u0026rsquo; pour un point. On voudra commenter la cohérence de cette situation dans un sens ou un autre: ce sera donc la luminance pour la partie imaginaire. Et on met une saturation constante. La teinte est coefficientée de telle sorte qu\u0026rsquo;un nombre entier de tours (12) nous ramène au rouge.\nL\u0026rsquo;autre fragment shader contient la formule, et deux textures sont interverties en lecture-écriture pour accumuler la somme. La programmation en glsl/WebGL est admirablement claire avec sa nature SIMD; On donne les coordonnées (x,y) d\u0026rsquo;un pixel, et charge au programmeur de déterminer la couleur de ce pixel:\nvoid main(void) { vec2 a = gl_FragCoord.xy / 512.0; # mise à l\u0026#39;echelle de xy vec2 prev = texture2D(u_calcSamp, a).xy; # valeur précedente # formule de Cauchy vec2 delta = a - u_z; float denom = dot(delta, delta); gl_FragColor = vec4( # rgba en sortie prev.x + (delta.x * u_dz.y - delta.y * u_dz.x) / denom, # réel en rouge prev.y + dot(delta, u_dz) / denom, # imaginaire en vert 1.0, 1.0 ); } Si programmer en glsl/WebGL vous tente, je recommande vivement le site Shadertoy.\nPar ailleurs je mesure le temps entre deux animation frames, et met autant de cycles de calcul que possible en essayant de ne pas dépasser 40ms entre deux frames.\nC\u0026rsquo;est à peu près tout, le reste du code est de la colle, de l\u0026rsquo;UI, et des fonctionalités classiques.\n","permalink":"https://benoit.paris/fr/posts/winding-cauchy-integral/","title":"Indice d'une courbe autour d'un point avec une Intégrale de Cauchy, en WebGL"}]