[{"content":"This what the winding number n(γ,a) of curve γ around point a, expressed as special case of Cauchy\u0026rsquo;s integral formula looks like on potentially-non-closed loops, with complex numbers mapped to a hue-luminance space.\n$$ n(\\gamma ,a) = \\frac{1}{2 \\pi i}\\int_{\\gamma}^{}\\frac{1}{z-a}dz $$\nDemo (drag your mouse on the red canvas, try to close loops)\nReset\rShuffle\rCircle\rSquare\rLevy Dragon\r+\r-\rThis animation requires WebGL\nEach pixel displays its winding number; hovering over it displays the real (Re) and imaginary (Im) part. Curves can be drawn with mouse dragging, some predefined shapes are available.\nThe formula In French math preparatory school, along the way to proving Cauchy’s Integral Formula, there\u0026rsquo;s this winding number which I always found remarquable. Out of seemingly innocuous operations on complex numbers it outputs a real integer number! And to top it mysteriously is the number of turns a curve takes around a point. But the curve has to be closed.\nDo not ask me to intuitively explain why it does that. In fact, I built this visualization to tinker with that formula and investigate. You can go over there to try to make sense of it.\nBut what if you don\u0026rsquo;t close the loop? Turns out the formula outputs \u0026lsquo;undefined\u0026rsquo;, in the form of a complex part to the winding number. One part is positive (high luminance) if the curve has too much \u0026lsquo;going to\u0026rsquo; and negative (low luminance) if not. To make the canvas mostly real, you may want to go from areas in need of \u0026lsquo;going to\u0026rsquo; to areas that have too much of it, closing the loops!\nOf note is that the inverse of a curve is the same curve going backwards: same integral, replace $dz$ by $-dz$. Also integrating (~summing, here) is commutative, can be made in any order; this is the shuffle option.\nThis means you can split a bigger curve in two by adding a back and forth between two points on it and re-arranging the integrals. It is equivalent to identity, as you just added a curve and its inverse. And also merge two compatible smaller curves into a bigger one.\nSort of, minus the artefacts\nArtefacts Precision can be tuned so that smaller or bigger $dz$ are used. You\u0026rsquo;ll see smaller \u0026lsquo;black-white dotting\u0026rsquo;, but may experience higher integration loss accumulation.\nOn mobile you\u0026rsquo;ll probably experience inaccurate winding numbers: non-smooth colors inside closed loops. This is due to intermediate results being written to float textures, and WebGL on mobile often only has 4 bits per channel when desktop offers 16 bits.\nbig dz\nplay with it enough, and you\u0026rsquo;ll get Re like 100.1\nCode here\nBuilding it Well, if you want a ~500x500 pixel canvas for a curve of about 1000 elements that\u0026rsquo;s already 250 million operations; so this gives a great opportunity to use the GPU.\nI use two fragment shaders. One for projecting the real and imaginary parts -which I store as red and green in a texture- onto a hue-saturation-luminance space. I chose hue for the real part as it illustrates about the \u0026rsquo;nature\u0026rsquo; of the output; as we want some king of fading out of this clear result when we get too imaginary. So luminance for the imaginary part, and saturation is constant.\nThe other fragment shader contains the formula, and I switch back and forth between two textures for summing up the result. Programming in WebGL is refreshingly simple once one understand its SIMD nature: In goes a single (x,y) coordinate, and the programmer is tasked with defining what the outgoing color for this single pixel is:\nvoid main(void) { vec2 a = gl_FragCoord.xy / 512.0; # scale xy vec2 prev = texture2D(u_calcSamp, a).xy; # fetch previous value # compute Cauchy formula vec2 delta = a - u_z; float denom = dot(delta, delta); gl_FragColor = vec4( # output is rgba prev.x + (delta.x * u_dz.y - delta.y * u_dz.x) / denom, # real in red prev.y + dot(delta, u_dz) / denom, # imaginary in green 1.0, 1.0 ); } If you want to start tinkering with WebGL, I highly recommend you checkout Shadertoy.\nI also monitor time between animation frames, and try to cram as many cycles as I can while targeting 40 ms/frame.\nAnd really that\u0026rsquo;s all there is to it; the rest is glue code, UI, and basic features.\nbien expliciter que a c\u0026rsquo;est chaque pixel, qu\u0026rsquo;on peut hover pour avoir la valeur qu\u0026rsquo;on peut drag pour faire une ligne et que cette ligne c\u0026rsquo;est gamma, avec z la position au moment de drag et dz un micro segment qu\u0026rsquo;on peut spécifier avec la précision, et que c\u0026rsquo;est une somme, hein, on fait pas les choses analytiquement\nLines compose: closing a line on itself can be done randomly, or at a later time Partir de la formule et voir les symétries\nThere\u0026rsquo;s a multitude of ways to put things on the real plane: like a multitude of ways to reach point A from B\nClosed forms which share a border going on the other direction can form a bigger structure corrolary: you can split a bigger closed loop into 2, and conserve the realness\nDisqus comments??\n","permalink":"https://benoit.paris/posts/winding-cauchy-integral/","title":"Winding numbers using a Cauchy integral, with WebGL"}]