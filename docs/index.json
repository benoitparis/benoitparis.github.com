[{"content":"Winding numbers using a Cauchy integral, with WebGL This is what the winding number n(γ,a) of curve γ around point a, expressed as special case of Cauchy\u0026rsquo;s integral formula looks like on potentially non-closed loops, with complex numbers mapped to a hue-luminance space.\n$$ n(\\gamma ,a) = \\frac{1}{2 \\pi i}\\int_{\\gamma}^{}\\frac{1}{z-a}dz $$\nDemo (drag your mouse across the red canvas)\nReset\rShuffle\rCircle\rSquare\rLevy Dragon\r+\r-\rThis animation requires WebGL\nEach pixel displays its complex winding number: Real part as Hue, Imaginary part as Luminance. Curves can be drawn with mouse dragging, some predefined shapes are available.\nThe formula Along the way to proving Cauchy’s Integral Formula, there\u0026rsquo;s this winding number which I found remarquable. Out of seemingly innocuous operations on complex numbers it always outputs a real integer number; And it mysteriously is the number of turns a curve takes around a point! But the curve has to be closed.\nDo not ask me to intuitively explain why it does that. In fact, I built this visualization to tinker with that formula and investigate. You can go over there to try to make sense of it.\nBut what if you don\u0026rsquo;t close the loop? Turns out the formula outputs \u0026lsquo;undefined\u0026rsquo;, in the form of a complex part to the winding number. One area is positive (high luminance) if it had too much \u0026lsquo;going to\u0026rsquo; and negative (low luminance) if too little. To make the canvas mostly Real, you want to go from areas in need of \u0026lsquo;going to\u0026rsquo; to areas that have too much of it, closing the loops! So the formula even comes with a debug function.\nOf note is that the inverse of a curve is the same curve going backwards: same integral, replace $dz$ by $-dz$. Also integrating (~summing, here) is commutative and can be made in any order; this is the shuffle option.\nThis means you can split a bigger curve in two by adding a back and forth between two points on it, re-arranging the integrals. It is equivalent to identity, as you just added a curve and its inverse. And vice versa: merge two compatible smaller curves into a bigger one.\nSort of, minus the visual glitches\nVisual glitches Precision can be tuned so that smaller or bigger $dz$ are used. A finer precision will give smaller black-white dottings, more integration accuracy, and lower speed; but you may also experience higher float loss accumulation.\nOn mobile you\u0026rsquo;ll probably experience inaccurate winding numbers: non-smooth colors inside closed loops. This is due to intermediate results being written to float textures, and WebGL on mobile often only has 4 bits per channel when desktop offers 16 bits.\nCode Here\nBuilding it Well, if you want a ~500x500 pixel canvas for a curve of about 1000 elements that\u0026rsquo;s already 250 million operations; so this gives a great opportunity to use the GPU.\nI use two fragment shaders. One for projecting the real and imaginary parts -which I store as the red and green channels in a texture- onto a hue-saturation-luminance space. I chose hue for the real part as it illustrates about the \u0026rsquo;nature\u0026rsquo; of the output; while we want some king of fading out of this clear result when we get too imaginary. So luminance for the imaginary part, and saturation is constant. Hue is scaled in order that a round number of windings (12) gets you back to red.\nThe other fragment shader contains the formula, and I switch back and forth between reading and writing to two textures to accumulate the sum. Programming in glsl/WebGL feels refreshingly simple with its SIMD nature. In goes a single (x,y) pixel coordinate, and the programmer is tasked with defining what the outgoing color for this single pixel is:\nvoid main(void) { vec2 a = gl_FragCoord.xy / 512.0; # scale xy vec2 prev = texture2D(u_calcSamp, a).xy; # fetch previous value # compute Cauchy formula vec2 delta = a - u_z; float denom = dot(delta, delta); gl_FragColor = vec4( # output is rgba prev.x + (delta.x * u_dz.y - delta.y * u_dz.x) / denom, # real in red prev.y + dot(delta, u_dz) / denom, # imaginary in green 1.0, 1.0 ); } If you want to start tinkering with glsl/WebGL, I highly recommend you checkout Shadertoy.\nI also monitor time between animation frames, and cram in as many calculation cycles as possible while trying to maintain at most 40 ms between frames.\nAnd that\u0026rsquo;s about all there is to it; the rest is glue code, UI, and basic features.\n","permalink":"https://benoit.paris/posts/winding-cauchy-integral/","title":"Winding numbers using a Cauchy integral, with WebGL"}]