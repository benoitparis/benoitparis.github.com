[{"content":"This what the winding number n(γ,a) of curve γ around point a, expressed as special case of Cauchy\u0026rsquo;s integral formula looks like on potentially-non-closed loops, with complex numbers mapped to a hue-luminance space.\n$$ n(\\gamma ,a) = \\frac{1}{2 \\pi i}\\int_{\\gamma}^{}\\frac{1}{z-a}dz $$\nDemo (drag your mouse across the red canvas, try to close loops)\nReset\rShuffle\rCircle\rSquare\rLevy Dragon\r+\r-\rThis animation requires WebGL\nEach pixel displays its complex winding number: Real part as Hue, Imaginary part as Luminance. Curves can be drawn with mouse dragging, some predefined shapes are available.\nThe formula Along the way to proving Cauchy’s Integral Formula, there\u0026rsquo;s this winding number which I always found remarquable. Out of seemingly innocuous operations on complex numbers it outputs a real integer number; And it mysteriously is the number of turns a curve takes around a point! But the curve has to be closed.\nDo not ask me to intuitively explain why it does that. In fact, I built this visualization to tinker with that formula and investigate. You can go over there to try to make sense of it.\nBut what if you don\u0026rsquo;t close the loop? Turns out the formula outputs \u0026lsquo;undefined\u0026rsquo;, in the form of a complex part to the winding number. One part is positive (high luminance) if the curve has too much \u0026lsquo;going to\u0026rsquo; and negative (low luminance) if not. To make the canvas mostly Real, you want to go from areas in need of \u0026lsquo;going to\u0026rsquo; to areas that have too much of it, closing the loops!\nOf note is that the inverse of a curve is the same curve going backwards: same integral, replace $dz$ by $-dz$. Also integrating (~summing, here) is commutative, can be made in any order; this is the shuffle option.\nThis means you can split a bigger curve in two by adding a back and forth between two points on it and re-arranging the integrals. It is equivalent to identity, as you just added a curve and its inverse. And also merge two compatible smaller curves into a bigger one.\nSort of, minus the artefacts\nArtefacts Precision can be tuned so that smaller or bigger $dz$ are used. You\u0026rsquo;ll see smaller \u0026lsquo;black-white dotting\u0026rsquo;, but may experience higher integration loss accumulation.\nOn mobile you\u0026rsquo;ll probably experience inaccurate winding numbers: non-smooth colors inside closed loops. This is due to intermediate results being written to float textures, and WebGL on mobile often only has 4 bits per channel when desktop offers 16 bits.\nCode Here\nBuilding it Well, if you want a ~500x500 pixel canvas for a curve of about 1000 elements that\u0026rsquo;s already 250 million operations; so this gives a great opportunity to use the GPU.\nI use two fragment shaders. One for projecting the real and imaginary parts -which I store as the red and green channels in a texture- onto a hue-saturation-luminance space. I chose hue for the real part as it illustrates about the \u0026rsquo;nature\u0026rsquo; of the output; while we want some king of fading out of this clear result when we get too imaginary. So luminance for the imaginary part, and saturation is constant. I scaled Hue so that on a round number of windings (12) you get back to red.\nThe other fragment shader contains the formula, and I switch back and forth between reading and writing to two textures to accumulate the result. Programming in WebGL feels refreshingly simple with its SIMD nature: In goes a single (x,y) pixel coordinate, and the programmer is tasked with defining what the outgoing color for this single pixel is:\nvoid main(void) { vec2 a = gl_FragCoord.xy / 512.0; # scale xy vec2 prev = texture2D(u_calcSamp, a).xy; # fetch previous value # compute Cauchy formula vec2 delta = a - u_z; float denom = dot(delta, delta); gl_FragColor = vec4( # output is rgba prev.x + (delta.x * u_dz.y - delta.y * u_dz.x) / denom, # real in red prev.y + dot(delta, u_dz) / denom, # imaginary in green 1.0, 1.0 ); } If you want to start tinkering with WebGL, I highly recommend you checkout Shadertoy.\nI also monitor time between animation frames, and cram as many calculation cycles as possible while trying to maintain 40 ms/frame.\nAnd that\u0026rsquo;s about all there is to it; the rest is glue code, UI, and basic features.\n","permalink":"https://benoit.paris/posts/winding-cauchy-integral/","title":"Winding numbers using a Cauchy integral, with WebGL"}]